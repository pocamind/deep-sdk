# This file is automatically generated by pyo3_stub_gen
# ruff: noqa: E501, F401, F403, F405

import builtins
import typing
__all__ = [
    "Atom",
    "Clause",
    "DeepData",
    "OptionalGroup",
    "Reqfile",
    "Requirement",
    "StatMap",
]

@typing.final
class Atom:
    @property
    def value(self) -> builtins.int: ...
    @property
    def strict(self) -> builtins.bool:
        r"""
        True if this atom is strict (cannot be reduced by oaths/builds)
        """
    @property
    def stats(self) -> builtins.list[builtins.str]:
        r"""
        The stat names (full names) that sum to meet the value
        """
    def satisfied_by(self, statmap: StatMap) -> builtins.bool: ...
    def is_empty(self) -> builtins.bool: ...
    def __str__(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...

@typing.final
class Clause:
    @property
    def is_and(self) -> builtins.bool:
        r"""
        True if all atoms must be satisfied (AND clause)
        """
    @property
    def is_or(self) -> builtins.bool:
        r"""
        True if any atom satisfies the clause (OR clause)
        """
    @property
    def atoms(self) -> builtins.list[Atom]: ...
    def satisfied_by(self, statmap: StatMap) -> builtins.bool: ...
    def is_empty(self) -> builtins.bool: ...
    def __str__(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...

@typing.final
class DeepData:
    @staticmethod
    def fetch_latest() -> DeepData:
        r"""
        Fetch the latest data bundle from pocamind/data on GitHub
        """
    @staticmethod
    def fetch_latest_from(owner: builtins.str, repo: builtins.str) -> DeepData:
        r"""
        Fetch the latest data bundle from a fork
        """
    @staticmethod
    def from_json(json: builtins.str) -> DeepData:
        r"""
        Parse data from a JSON string
        """
    def get_talent(self, name: builtins.str) -> typing.Optional[builtins.str]:
        r"""
        Returns JSON string or None
        """
    def get_mantra(self, name: builtins.str) -> typing.Optional[builtins.str]:
        r"""
        Returns JSON string or None
        """
    def get_weapon(self, name: builtins.str) -> typing.Optional[builtins.str]:
        r"""
        Returns JSON string or None
        """
    def get_outfit(self, name: builtins.str) -> typing.Optional[builtins.str]:
        r"""
        Returns JSON string or None
        """
    def get_aspect(self, name: builtins.str) -> typing.Optional[builtins.str]:
        r"""
        Returns JSON string or None
        """
    def talents(self) -> builtins.str:
        r"""
        Returns JSON array string of all talents
        """
    def mantras(self) -> builtins.str:
        r"""
        Returns JSON array string of all mantras
        """
    def weapons(self) -> builtins.str:
        r"""
        Returns JSON array string of all weapons
        """
    def outfits(self) -> builtins.str:
        r"""
        Returns JSON array string of all outfits
        """
    def aspects(self) -> builtins.str:
        r"""
        Returns JSON array string of all aspects
        """

@typing.final
class OptionalGroup:
    @property
    def general(self) -> builtins.list[Requirement]:
        r"""
        Requirements acquired freely (before power gate)
        """
    @property
    def post(self) -> builtins.list[Requirement]:
        r"""
        Requirements acquired after a power gate
        """
    @property
    def weight(self) -> builtins.int: ...

@typing.final
class Reqfile:
    @property
    def general(self) -> builtins.list[Requirement]:
        r"""
        Required requirements acquired freely (before power gate)
        """
    @property
    def post(self) -> builtins.list[Requirement]:
        r"""
        Required requirements acquired after a power gate
        """
    @property
    def optional(self) -> builtins.list[OptionalGroup]:
        r"""
        Optional groups â€” each group is either all acquired or all not
        """
    @staticmethod
    def from_str(s: builtins.str) -> Reqfile: ...
    def generate(self) -> builtins.str:
        r"""
        Regenerate the reqfile string from the parsed representation
        """

@typing.final
class Requirement:
    @property
    def name(self) -> typing.Optional[builtins.str]: ...
    @property
    def prereqs(self) -> builtins.list[builtins.str]:
        r"""
        DIRECT prerequisites by name (does not include transitive)
        """
    @property
    def clauses(self) -> builtins.list[Clause]: ...
    @staticmethod
    def from_str(s: builtins.str) -> Requirement: ...
    def satisfied_by(self, statmap: StatMap) -> builtins.bool: ...
    def is_empty(self) -> builtins.bool: ...
    def atoms(self) -> builtins.list[Atom]:
        r"""
        Flat iterator over all atoms across all clauses
        """
    def used_stats(self) -> builtins.list[builtins.str]:
        r"""
        All stats referenced in this requirement (sorted, excludes Total)
        """
    def __str__(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...

@typing.final
class StatMap:
    def __new__(cls, map: typing.Mapping[builtins.str, builtins.int]) -> StatMap: ...
    def cost(self) -> builtins.int: ...
    def remaining(self) -> builtins.int: ...
    def level(self) -> builtins.int: ...
    def get(self, stat: builtins.str) -> builtins.int: ...
    def set(self, stat: builtins.str, value: builtins.int) -> None: ...
    def to_json(self) -> builtins.str: ...

